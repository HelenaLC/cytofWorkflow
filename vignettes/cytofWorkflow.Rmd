---
title: "CyTOF workflow"
author: 
  - name: Malgorzata Nowicka
    affiliation: a,b
    email: gosia.nowicka@uzh.ch
  - name: Mark D. Robinson
    affiliation: a,b
address:
  - code: a
    address: Institute for Molecular Life Sciences, University of Zurich, Zurich, 8057, Switzerland
  - code: b
    address: SIB Swiss Institute of Bioinformatics, University of Zurich, Zurich, 8057, Switzerland
abstract: Abstract. 
documentclass: extarticle
fontsize: 10pt
papersize: a4
bibliography: bibliography.bib
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{CyTOF workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

<!-- To render this document: -->

<!-- cd cytofWorkflow/vignettes -->

<!-- rmarkdown::render('cytofWorkflow.Rmd') -->

<!-- knitr::purl('cytofWorkflow.Rmd') -->


```{r setup_knitr, include=FALSE, cache=FALSE}
library(knitr)
knitr::opts_chunk$set(cache = 2, warning = FALSE, message = FALSE, cache.path = "cache/", fig.path = "figure/")
```


# Introduction

<!-- Describe what CyTOF and Flow Cytometry are and what are the differences -->

Flow cytometry and more recently introduced CyTOF (cytometry by time-of-flight mass spectrometry or mass cytometry) are technologies that measure abundance of proteins expressed on the surface or inside cells at the high-throughput single cell level. 
In flow cytometry, antibodies are labeled with fluorescent dyes. For each cell, the intensity of fluorescent parameters is measured using lasers and photodetectors. 
CyTOF utilizes an entirely different technique. Transition element isotopes are used to label antibodies and the intensity read out of isotopes bound to each cell is analyzed with a time-of-flight mass spectrometer. 
In both cases, the intensity of either fluorescent dyes or isotopes is assumed to be proportional to the expression level of antibody-targeted antigens of interest.

Due to the huge differences in these techniques other distinct characteristics are observed.
Classical fluorophore-based flow cytometry is non-destructive and can be also used for cell sorting allowing further analysis on cell populations. Because of the spectral overlap between fluorophores, the compensation analysis has to be performed and a limited number of parameters can be measured at once. A routine experiment measures around 18 parameters with recent increase to up to 50 parameters. On the other hand, flow cytometry offers a high throughput with 10,000 cells measured per second at relatively low operating costs per sample.

By using rare metal isotopes in CyTOF, there is no problem of cell autofluorescence which is a limitation in the classical flow cytometry. As the spectral overlap is greatly reduced, there is almost no need for compensation and a greater number of parameters per cell can be detected. Currently, around 40 parameters can be detected with mass cytometry and theoretically this number could be increased to more than 100 parameters. However, the throughput of CyTOF is lower which is at the rate of hundreds of cells per second and cells can not be collected after an experiment as they are destroyed during the mass spectrometry step.


<!-- Application -->

The ability of flow cytometry and mass cytometry to analyze individual cells at such a high-throughput resulted in a wide range of biological and medical applications. In immunology, they are used to detect and quantify cell populations of interest, to characterize unknown cell populations and to compare population abundance between different conditions, such as different patient groups, resulting in disease biomarker identification.

<!-- Explain what is presented in this workflow -->

In this workflow, we present an analysis of CyTOF data where the goal is to first, identify cell populations of interest and second, determine which of the cell subpopulations and protein markers could be used as biomarkers to distinguish between healthy and sick patients. We present how to visualize the obtained cell populations with t-SNE as a dimension reduction technique from `r CRANpkg("Rtsne")`. We use `r CRANpkg("pheatmap")` to plot heatmaps that represent characteristics of cell populations and biomarkers. 

The CyTOF data used here is already pre-processed meaning that the normalization and debarcoding as well as removal of doublets, debris and dead cells were already performed, see Section [Data preprocessing](#data-preprocessing).
This workflow is equally applicable to any flow cytometry data for which the pre-processing including compensation and the steps listed above were performed. 

Cell population identification often has been carried out by manual gating a method based on visual inspection of two-dimensional scatterplots, where at each step a subset of cells, which is positive or negative for the given two markers, is selected and further stratified in the next iteration until a population with given marker characteristics is selected. Despite its popularity, manual gating has many drawbacks such as subjectivity, bias toward the favorite cell types, high time workload and inefficiency when analyzing large datasets, which all contribute to the fact that manual gating is hard to reproduce [@Saeys2016].
Large effort has been carried out to improve and automate cell population identification and many methods are currently available that address this question by the means of unsupervised clustering of cells [@Weber2016]. 

In this pipeline, cell clustering is conducted with `r Biocpkg("FlowSOM")` and `r CRANpkg("ConsensusClusterPlus")` packages, one of the best performing clustering approaches [@Weber2016]. 

<!-- Should I mention that there are the following methods: classification, regression and survival analysis? -->

Biomarker discovery aims to identify cell subpopulations for which the abundances change between the biological conditions giving an insight into the cause or effect of the phenotypic differences.
There are two main approaches to biomarker identification [@Saeys2016]. First, clustering and then performing a statistical test, which is presented in this workflow. Second, strong over-clustering plus feature selection to detect the most relevant subpopulations. 
In addition to differentially abundant subpopulations, we identify protein markers for which the expression changes between the biological conditions.

We conduct the differential analysis of cell population abundances and marker intensities using the generalized linear mixed models (GLMM) and linear mixed models (LMM), respectively, which allow for modeling more complex designs that can account for batch effects and paired experiments. The analysis are performed using the `r CRANpkg("lme4")` and `r CRANpkg("multcomp")` packages.

Cell population abundances are represented as counts of cells in a given cluster and sample. Our goal is to compare the relative abundance, meaning the ratios, of cell subpopulations and not the absolute counts. 
This can be done with the binomial model, which naturally accounts for the higher uncertainty of proportions based on lower counts, and which is not the case when proportions are modeled directly.
However, as in the genomic data analysis [@Jia2014, @Zhao2013], the pure logistic regression is not able to model the overdispersion which we have also observed in this type of data. 
A more suitable model would be based on the beta-binomial distribution, or similar results can be achieved by modeling the extra variance of relative ratios as random effects for each individual sample in the generalized linear mixed models (GLMM).

The differential analysis of marker expression are performed using the median expression from each sample as a dependent variable in the linear model (LM). 
One drawback of this approach is that all the other characteristics of the protein marker intensity distribution, such as bimodality, skewness and variance, are ignored. 
On the other hand, considering only median results in a simple, easy to interpret approach which in many cases is sufficient for the exploratory analysis. 
Other issue that arises when using a summary statistic of a distribution is its uncertainty which increases as the number of cells used to calculate the median decreases. 
This problem can be handled in the linear model by assigning weights to the median expression which are proportional to the number of cells.  

The data analyzed in this workflow originates from a paired experiment. Samples from the same patients were taken in condition A and B. This is a classic example where one would choose mixed models over the traditional models, and patients would be treated as a random effect. Due to this we introduce some modifications to the approaches described above. 
In the differential cell population abundance analysis, in the GLMM, we use patient IDs as a random effect instead of the sample IDs. In the differential median marker expression analysis, we use a linear mixed model (LMM) with patient IDs as a random effect instead of the LM.


The workflow is not fully automatic, it involves a step where the user can manually merge and annotate clusters, see Section [Cluster merging and annotation](#cluster-merging-and-annotation), but it is entirely and easily reproducible.

# Data description

The dataset used here is not yet publicly available. For this reason, we had to anonymize conditions for which samples were collected and antigens used in the panel. The two conditions are called A and B and in both of them samples were obtained from healthy and sick patients. The antigen names were changed to "M1", "M2",..., "M23". 

# Data preprocessing

<!-- From Carsten: -->

Peripheral blood mononuclear cell (PBMC) staining and acquisition by mass cytometry were performed as described previously (Hartmann et al. 2017 ???). Data was normalized using the standalone MATLAB normalizer (Version 2013b) [@Finck2013], marker expression was controlled in FlowJo (Version10.1r5) by using a biologic positive and negative control and patient samples were debarcoded using Boolean gating.

(TODO? Description of how the pre-processing could be done. Reference to the CATALYST package.)


# Data importing and normalization

Currently, FCS, metadata and panel files are available in the `extdata` subdirectory of this package installation.

In the future, all of them will be available on FlowRepository so I will have to describe how to download them.

```{r data_dir}
library(cytofWorkflow)

data_dir <- system.file("extdata", package = "cytofWorkflow")

```


Load metadata and panel files:

```{r load_metadata}
library(gdata)

md <- read.xls(file.path(data_dir, "cytofWorkflow_metadata.xls"), stringsAsFactors = FALSE)

rownames(md) <- md$short_name

## Make sure condition variables are factors with the right levels
md$condition1 <- factor(md$condition1, levels = c("Healthy", "Sick"))
md$condition2 <- factor(md$condition2, levels = c("A", "B"))
md$condition <- interaction(md$condition2, md$condition1, sep = "_", lex.order = TRUE)
## Add colors
md$color <- factor(md$condition, labels = c("#BC80BD", "#984EA3", "#80B1D3", "#FF7F00"))
md

color_samples <- as.character(md$color)
names(color_samples) <- md$short_name

colors <- unique(md[, c("condition", "color")])
color_conditions <- as.character(colors$color)
names(color_conditions) <- colors$condition
```

```{r load_panel}
panel <- read.xls(file.path(data_dir, "cytofWorkflow_panel.xls"), stringsAsFactors = FALSE)
head(panel)
```


An alternative to the approach below would be to use the `cytof_exprsMerge` function from `cytofkit`.

Load the raw FCS files:

```{r load_fcs}
library(flowCore)

file_names <- file.path(data_dir, md$file_name)
fcs_raw <- read.flowSet(file_names)
```

Extract the expression data for markers with `panel$Use` equal to 1, and normalize it using the arcsinh transformation:

```{r arcsinh_normalization}
## Find which markers to use
fcs_colnames <- colnames(fcs_raw)
fcs_isotope <- as.numeric(gsub("[[:alpha:]]", "", fcs_colnames))
mm <- match(panel$Isotope, fcs_isotope)
panel$fcs_colnames <- fcs_colnames[mm]
keep <- panel$fcs_colnames[panel$Use == 1]

## Extract expression + arcsineh normalization
expr <- fsApply(fcs_raw, exprs)
expr <- asinh(expr[, keep] / 5)
colnames(expr) <- panel$Antigen[panel$Use == 1]
```

Normalize the expression data to 0-1. Useful when for plotting heatmaps.

```{r 01_normalization}
rng <- apply(expr, 2, quantile, p = c(0.01, 0.99))

expr01 <- t((t(expr) - rng[1, ]) / (rng[2, ] - rng[1, ]))

expr01[expr01 < 0] <- 0
expr01[expr01 > 1] <- 1

```

Generate a variable with sample IDs.

```{r sample_ids}
sample_ids <- rep(md$short_name, fsApply(fcs_raw, nrow))
```

Plot distributions of marker expression.

```{r plot_merker_expression_distribution}
library(ggplot2)
library(reshape2)

ggdf <- data.frame(sample_id = sample_ids, expr)
ggdf <- melt(ggdf, id.var = "sample_id", value.name = "expression", variable.name = "antigen")
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition <- md$condition[mm]

ggplot(ggdf, aes(x = expression, color = condition, group = sample_id)) +
  geom_density() +
  facet_wrap(~ antigen, nrow = 4, scales = "free") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.title = element_blank(), legend.position = "right") +
  guides(color = guide_legend(ncol = 1)) +
  scale_color_manual(values = color_conditions)

```


Plot number of cells per sample

```{r plot_number_of_cells}
cell_table <- table(sample_ids)

ggdf <- data.frame(sample_id = names(cell_table), cell_counts = as.numeric(cell_table))

ggplot(ggdf, aes(x = sample_id, y = cell_counts, fill = sample_id)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = cell_counts), hjust=0.5, vjust=-0.5, size = 3) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1), legend.position = "none") +
  scale_fill_manual(values = color_samples, drop = FALSE) +
  scale_x_discrete(drop = FALSE)
```


# Marker ranking based on the non-redundancy score

The non-redundancy score (NRS) [@Levine2015] based on the PCA analysis.
Explain in detail why we calculate it. Useful if we want to work with a subset of markers but here we run the analysis with all the markers. 


```{r nrs_function}
NRS <- function(x, ncomp = 3){
  pr <- prcomp(x, center = TRUE, scale. = FALSE) 
  score <- rowSums(outer(rep(1, ncol(x)), pr$sdev[1:ncomp]^2) * abs(pr$rotation[,1:ncomp]))
  return(score)
}
```

```{r nrs_calculate}
## Split expression per sample
expr_split <- split(data.frame(expr), sample_ids)

nrs_sample <- sapply(expr_split, NRS)

nrs <- rowMeans(nrs_sample, na.rm = TRUE)
```


```{r plot_nrs}
## Plot NRS scores for ordered markers
antigens_ordered <- names(sort(nrs, decreasing = TRUE))

nrs_sample <- data.frame(nrs_sample)
nrs_sample$antigen <- rownames(nrs_sample)

ggdf <- melt(nrs_sample, id.var = "antigen", value.name = "nrs", variable.name = "sample_id")
ggdf$antigen <- factor(ggdf$antigen, levels = antigens_ordered)
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition <- md$condition[mm]

ggplot(ggdf, aes(x = antigen, y = nrs)) +
geom_point(aes(color = condition), alpha = 0.8, position = position_jitter(width = 0.3, height = 0)) +
  geom_boxplot(outlier.size = NA, fill = NA) +
  stat_summary(fun.y = "mean", geom = "point", shape = 21, fill = "white") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_color_manual(values = color_conditions) 

```

# MDS plot

```{r mds_median_expression}
# Get the median marker expression per sample
expr_median_sample <- aggregate(expr, by = list(sample_id = sample_ids), FUN = median)
rownames(expr_median_sample) <- expr_median_sample[, 1]
expr_median_sample <- t(expr_median_sample[, -1])
```

```{r mds_plotMDS}
library(limma)
mds <- plotMDS(expr_median_sample, plot = FALSE)
```


```{r mds_plot}
ggdf <- data.frame(PCA1 = mds$x, PCA2 = mds$y, sample_id = colnames(expr_median_sample))
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition <- md$condition[mm]

ggplot(ggdf, aes(x = PCA1, y = PCA2, color = condition)) +
  geom_point(size = 2) +
  geom_text(aes(label = sample_id), vjust = -0.5) +
  xlim(-1.2, 1.2) +
  theme_bw() +
  scale_color_manual(values = color_conditions) 

```


# Cell population identification with FlowSOM

Explain that identifying meaningful clusters is one of the most challenging parts and all the downstream analysis depend on it.
We use a slight modification of the FlowSOM workflow presented in its vignette. We find it more flexible.

```{r flowsom_som}
library(FlowSOM)
library(ConsensusClusterPlus)

## Run SOM with 100 clusters
set.seed(1234)
som <- SOM(expr)
```


```{r flowsom_meta_clustering, message = FALSE}
## Meta clustering into 20 clusters with ConsensusClusterPlus
codes <- som$codes
plot_outdir <- "consensus_plots"
nmc <- 20

mc <- ConsensusClusterPlus(t(codes), maxK = nmc, reps = 100, pItem = 0.9, pFeature = 1, title = plot_outdir, plot = "png", clusterAlg = "hc", innerLinkage = "average", finalLinkage = "average", distance = "euclidean", seed = 1234)

## Get cluster ids for each cell
code_clustering <- mc[[nmc]]$consensusClass
cell_clustering <- code_clustering[som$mapping[,1]]
```

One of the plots produced by `ConsensusClusterPlus` represents a score for each possible number of clusters from 2 to `r nmc`. It can be used for the elbow criterion to define the optimal number of clusters.

![Delta area](consensus_plots/consensus022.png)

You can also plot the SOM codes.

```{r som_codes_size}
## Get code sizes; sometimes not all the codes have mapped cells so they will have size 0
code_sizes <- table(factor(som$mapping[, 1], levels = 1:nrow(codes))) 
code_sizes <- as.numeric(code_sizes)

```

```{r som_codes_dimension_reduction}
## t-SNE dimension reduction with cytofkit when setting pca = FALSE does not work!
## So we use the Rtsne package directly.

# library(cytofkit)
# 
# codes_dr <- cytof_dimReduction(codes, method = "tsne", tsneSeed = 1234)
# colnames(codes_dr) <- c("dim1", "dim2")

## Run t-SNE
library(Rtsne)

set.seed(1234)
tsne_out <- Rtsne(codes, pca = FALSE)

```


```{r color_clusters}
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3", "#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999")

```


```{r plot_som_codes}
codes_dr <- data.frame(tSNE1 = tsne_out$Y[, 1], tSNE2 = tsne_out$Y[, 2])
codes_dr$cluster <- factor(code_clustering)
codes_dr$size <- code_sizes

ggplot(codes_dr,  aes(x = tSNE1, y = tSNE2, color = cluster, size = size)) +
  geom_point(alpha = 0.9) +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))

```

## Plotting heatmaps


```{r plot_heatmap}
library(RColorBrewer)
library(pheatmap)

plot_clustering_heatmap_wrapper <- function(expr, expr01, cell_clustering, color_clusters){
  
  # Get the median expression
  expr_median <- aggregate(expr, by = list(cell_clustering), FUN = median)
  expr01_median <- aggregate(expr01, by = list(cell_clustering), FUN = median)
  
  # Get cluster frequencies
  clustering_table <- as.numeric(table(cell_clustering))
  
  # This clustering is based on the markers that were used for the main clustering
  d <- dist(expr_median[, antigens_ordered], method = "euclidean")
  cluster_rows <- hclust(d, method = "average")
  
  expr_heat <- as.matrix(expr01_median[, antigens_ordered])
  rownames(expr_heat) <- expr01_median[, 1]
  
  labels_row <- paste0(rownames(expr_heat), " (", round(clustering_table / sum(clustering_table) * 100, 2), "%)")
  labels_col <- colnames(expr_heat)
  
  # Row annotation for the heatmap
  annotation_row <- data.frame(cluster = rownames(expr_heat))
  rownames(annotation_row) <- rownames(expr_heat)
  
  names(color_clusters) <- rownames(expr_heat)
  annotation_colors <- list(cluster = color_clusters)
  
  # Colors for the heatmap
  color <- colorRampPalette(rev(brewer.pal(n = 8, name = "RdYlBu")))(100)
  
  pheatmap(expr_heat, color = color, cluster_cols = FALSE, cluster_rows = cluster_rows, labels_col = labels_col, labels_row = labels_row, display_numbers = TRUE, number_color = "black", fontsize_number = 4, annotation_row = annotation_row, annotation_colors = annotation_colors)
  
}

plot_clustering_heatmap_wrapper(expr, expr01, cell_clustering, color_clusters)

```


# Dimension reduction with t-SNE

Using only a subset of cells.

```{r tsne_duplicates_subsampling}
## Find and skip duplicates
dups <- which(!duplicated(expr))

## Data subsampling
## Create indices by sample
inds <- split(1:length(sample_ids), sample_ids) 

## How many cells to downsample per-sample
tsne_ncells <- pmin(table(sample_ids), 2000)  

## Get subsampled indices
set.seed(1234)
tsne_inds <- lapply(names(inds), function(i){
  s <- sample(inds[[i]], tsne_ncells[i], replace = FALSE)
  intersect(s, dups)
})

tsne_inds <- unlist(tsne_inds)

tsne_expr <- expr[tsne_inds, ]
```

```{r tsne_run}
## Run t-SNE
library(Rtsne)

set.seed(1234)
tsne_out <- Rtsne(tsne_expr, check_duplicates = FALSE, pca = FALSE)

```


```{r tsne_plot_one}
## Plot t-SNE
dr <- data.frame(tSNE1 = tsne_out$Y[, 1], tSNE2 = tsne_out$Y[, 2])
dr$sample_id <- sample_ids[tsne_inds]
dr$cell_clustering <- factor(cell_clustering[tsne_inds], levels = 1:nmc)

## One plot 
ggp <- ggplot(dr,  aes(x = tSNE1, y = tSNE2, color = cell_clustering)) +
  geom_point() +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))
ggp
```

```{r tsne_plot_facet_sample}
## Facet per sample
ggp + 
facet_wrap(~ sample_id) 
```


# Cluster merging and annotation


## Rerunning ConsensusClusterPlus with identified number of clusters

Applying the elbow criterion to the delta area Figure 1, we could deduce that there are 6 main clusters present in this dataset.

```{r flowsom_meta_clustering2, message = FALSE}
## Get cluster ids for each cell
nmc2 <- 6
code_clustering2 <- mc[[nmc2]]$consensusClass
cell_clustering2 <- code_clustering2[som$mapping[, 1]]
```


```{r plot_som_codes2}
## Plot new clustering2
codes_dr$cluster2 <- factor(code_clustering2)

ggplot(codes_dr,  aes(x = tSNE1, y = tSNE2, color = cluster2, size = size)) +
  geom_point(alpha = 0.9) +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))

```


```{r plot_heatmap2}
plot_clustering_heatmap_wrapper(expr, expr01, cell_clustering2, color_clusters[1:nmc2])

```


## Manual cluster merging based on the heatmap

(Should I rather use the `cutree()` function to get an 'automated' method for identifying clusters?)

```{r cluster_merging}
cluster_merging <- data.frame(original_cluster = 1:20, new_cluster = c("clA", "clH", "clH", "clF", "clH", "clE", "clB", "clF", "clG", "clB", "clE", "clE", "clG", "clD", "clB", "clC", "clD", "clB", "clB", "clC"))
cluster_merging

## New clustering3
mm <- match(cell_clustering, cluster_merging$original_cluster)
cell_clustering3 <- cluster_merging$new_cluster[mm]

mm <- match(code_clustering, cluster_merging$original_cluster)
code_clustering3 <- cluster_merging$new_cluster[mm]
```


```{r plot_som_codes3}
## Plot new clustering3
codes_dr$cluster3 <- factor(code_clustering3)

ggplot(codes_dr,  aes(x = tSNE1, y = tSNE2, color = cluster3, size = size)) +
  geom_point(alpha = 0.9) +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))
```


```{r plot_heatmap3, fig.cap='Heatmap for clustering3.'}
plot_clustering_heatmap_wrapper(expr, expr01, cell_clustering3, color_clusters[1:nlevels(cell_clustering3)])

```


# Differential analysis of cell population frequencies

Explain in details why we use GLMM.

Calculate cell frequencies in each cluster and sample


```{r diff_freqs}
freq_table <- table(cell_clustering3, sample_ids)
prop_table <- t(t(freq_table) / colSums(freq_table)) * 100

freq <- as.data.frame.matrix(freq_table)
prop <- as.data.frame.matrix(prop_table)
```

Fit a GLMM binomial with interactions and test contrasts.

```{r diff_freqs_define_model}
library(lme4)
library(multcomp)

## Define the model formula
model.matrix( ~ condition1 + condition2 + condition1:condition2, data = md)

## Create contrasts
contrast_names <- c("HvsS_A", "HvsS_B", "H_AvsS_B")
k1 <- c(0, 1, 0, 0)
k2 <- c(0, 1, 0, 1)
k3 <- c(0, 1, 1, 1)
K <- matrix(c(k1, k2, k3), nrow = 3, byrow = TRUE)
rownames(K) <- contrast_names
K

formula_glmer_binomial <- y/total ~ condition1 + condition2 + condition1:condition2 + (1|patient_id)
```


This approach works also when the experiment is not paired, i.e., there are unique patient IDs for each sample.

```{r diff_freqs_fit_model}
ntot <- colSums(freq)

### Fit the GLMM for each cluster separately
fit_binomial <- lapply(1:nrow(freq), function(i){

  data_tmp <- data.frame(y = as.numeric(freq[i, md$short_name]), total = ntot, md)

  fit_tmp <- glmer(formula_glmer_binomial, weights = total, family = binomial, data = data_tmp)

  ## Fit contrasts one by one
  out <- apply(K, 1, function(k){
    contr_tmp <- glht(fit_tmp, linfct = matrix(k, 1))
    summ_tmp <- summary(contr_tmp)
    pval <- summ_tmp$test$pvalues
    return(pval)
  })

  return(out)
  
})

pvals <- do.call(rbind, fit_binomial)
colnames(pvals) <- paste0("pval_", contrast_names)
rownames(pvals) <- rownames(freq)

## Adjust the p-values
adjp <- apply(pvals, 2, p.adjust, method = "BH")
colnames(adjp) <- paste0("adjp_", contrast_names)
adjp
```

## Plot proportions for all the clusters

We plot the proportions for contrast `"HvsS_A"`.

```{r diff_freqs_plot_props}
ggdf <- melt(data.frame(cluster = rownames(prop), prop), id.vars = "cluster", value.name = "proportion", variable.name = "sample_id")

## Add info about samples
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition1 <- factor(md$condition1[mm])
ggdf$condition2 <- factor(md$condition2[mm])
ggdf$condition <- factor(md$condition[mm])

## Plot for condition A
ggplot(ggdf[ggdf$condition2 == "A", , drop = FALSE]) +
  geom_boxplot(aes(x = condition, y = proportion, color = condition, fill = condition), position = position_dodge(), alpha = 0.5, outlier.color = NA) +
  geom_point(aes(x = condition, y = proportion, color = condition), alpha = 0.8, position = position_jitterdodge()) +
  facet_wrap(~ cluster, scales = "free", nrow = 2) +
  theme_bw() +
  theme(axis.text.x = element_blank(), 
    axis.ticks.x = element_blank()) +
  scale_color_manual(values = color_conditions) +
  scale_fill_manual(values = color_conditions)

```


## Plot heatmap with significant cell populations

We plot the proportions for contrast `"HvsS_A"`.
Enriched and depleted compartments.

```{r normalization_wrapper}
normalization_wrapper <- function(expr, th = 2.5){
  
  expr_norm <- apply(expr, 1, function(x){ 
    
    sdx <- sd(x, na.rm = TRUE)
    if(sdx == 0)
      x <- (x - mean(x, na.rm = TRUE))
    else 
      x <- (x - mean(x, na.rm = TRUE)) / sdx
    
    x[x > th] <- th
    x[x < -th] <- -th
    
    return(x)
  })
  
  expr_norm <- t(expr_norm)
  
}

```



```{r diff_freqs_asin_sqrt_transformation}
## Apply the arcsine-square-root transformation
asin_table <- asin(sqrt((t(t(freq_table) / colSums(freq_table)))))
asin <- as.data.frame.matrix(asin_table)

## Keep significant clusters for condition A and sort them by significance
FDR_cutoff <- 0.05
sign_clusters <- names(which(sort(adjp[, "adjp_HvsS_A"]) < FDR_cutoff))

## Keep samples for condition A and normalize to mean = 0 and sd = 1
asin_norm <- normalization_wrapper(asin[sign_clusters, md$short_name[md$condition2 == "A"]])

## Get the adjusted p-values
sign_adjp <- adjp[sign_clusters , "adjp_HvsS_A"]
```



```{r diff_freqs_plot_heatmap_with_significant_clusters}

plot_differential_heatmap_wrapper <- function(expr_norm, sign_adjp, condition, color_conditions, th = 2.5){
  
  ## Plot a heatmap
  labels_row <- paste0(rownames(expr_norm), " (", sprintf( "%.02e", sign_adjp), ")")
  labels_col <- colnames(expr_norm)
  
  annotation_col <- data.frame(condition = factor(condition))
  rownames(annotation_col) <- colnames(expr_norm)
  annotation_colors <- list(condition = color_conditions)
  
  color <- colorRampPalette(c("#87CEFA", "#56B4E9", "#0072B2", "#000000", "#D55E00", "#E69F00", "#FFD700"), space = "Lab")(100)
  breaks = seq(from = -th, to = th, length.out = 101)
  legend_breaks = seq(from = -round(th), to = round(th), by = 1)
  gaps_col <- as.numeric(table(annotation_col$condition))
  
  pheatmap(expr_norm, color = color, breaks = breaks, legend_breaks = legend_breaks, cluster_cols = FALSE, cluster_rows = FALSE, labels_col = labels_col, labels_row = labels_row, gaps_col = gaps_col, annotation_col = annotation_col, annotation_colors = annotation_colors, annotation_legend = FALSE)
  
  
}

plot_differential_heatmap_wrapper(expr_norm = asin_norm, sign_adjp = sign_adjp, condition = md[colnames(asin_norm), "condition"], color_conditions = color_conditions)

```



# Differential analysis of marker expression

## Overall marker expression

Using the `glmer` function with `family = gaussian` as shortcut to `lmer` is deparacated. One should use `lmer` directly.
`lmer` does not allow that the random effect is a variable that has unique values for each sample. Thus, sample IDs could not be used as a random effect.

```{r diff_expr1_fit_model}
formula_lmer <- y ~ condition1 + condition2 + condition1:condition2 + (1|patient_id)

### Fit the LMM for each marker separately
fit_gaussian <- lapply(1:nrow(expr_median_sample), function(i){
  # i = 1
  data_tmp <- data.frame(y = as.numeric(expr_median_sample[i, md$short_name]), md)

  fit_tmp <- lmer(formula_lmer, data = data_tmp)

  ## Fit contrasts one by one
  out <- apply(K, 1, function(k){
    contr_tmp <- glht(fit_tmp, linfct = matrix(k, 1))
    summ_tmp <- summary(contr_tmp)
    pval <- summ_tmp$test$pvalues
    return(pval)
  })

  return(out)
  
})

pvals <- do.call(rbind, fit_gaussian)
colnames(pvals) <- paste0("pval_", contrast_names)
rownames(pvals) <- rownames(expr_median_sample)

## Adjust the p-values
adjp <- apply(pvals, 2, p.adjust, method = "BH")
colnames(adjp) <- paste0("adjp_", contrast_names)
head(adjp)
```


### Plot median expression of all the markers

Sorted by significance

```{r diff_expr1_plot_median_expr}
ggdf <- melt(data.frame(antigen = rownames(expr_median_sample), expr_median_sample), id.vars = "antigen", value.name = "median_expression", variable.name = "sample_id")

## Sort antigen by significance
ggdf$antigen <- factor(ggdf$antigen, levels = names(sort(adjp[, "adjp_HvsS_A"])))

## Add info about samples
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition1 <- factor(md$condition1[mm])
ggdf$condition2 <- factor(md$condition2[mm])
ggdf$condition <- factor(md$condition[mm])

## Plot for condition A
ggplot(ggdf[ggdf$condition2 == "A", , drop = FALSE]) +
  geom_boxplot(aes(x = antigen, y = median_expression, color = condition, fill = condition), position = position_dodge(), alpha = 0.5, outlier.color = NA) +
  geom_point(aes(x = antigen, y = median_expression, color = condition), alpha = 0.8, position = position_jitterdodge()) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_color_manual(values = color_conditions) +
  scale_fill_manual(values = color_conditions)

```


### Plot heatmap with significant markers

```{r diff_expr1_plot_heatmap_with_significant_markers}
## Keep significant markers for condition A and sort them by significance
sign_markers <- names(which(sort(adjp[, "adjp_HvsS_A"]) < FDR_cutoff))

## Keep samples for condition A and normalize to mean = 0 and sd = 1
expr_median_sample_norm <- normalization_wrapper(expr_median_sample[sign_markers, md$short_name[md$condition2 == "A"]])

## Get the adjusted p-values
sign_adjp <- adjp[sign_markers , "adjp_HvsS_A"]

plot_differential_heatmap_wrapper(expr_norm = expr_median_sample_norm, sign_adjp = sign_adjp, condition = md[colnames(expr_median_sample_norm), "condition"], color_conditions = color_conditions)

```


## Marker expression stratified by cell population

There might be samples that have no cells assigned to a cluster or the number of cells is very low. This can be a problem as it introduces NAs because the median expression can not be calculated for such a sample or the median expression is calculated based on few cells which leads to higher uncertainty of this estimate.

We remove clusters which have too low counts.  

```{r diff_expr2_median_expression}

expr_median_sample_cluster <- aggregate(expr, by = list(sample_id = sample_ids, cluster = cell_clustering3), FUN = median, drop = FALSE)
expr_median_sample_cluster_melt <- melt(expr_median_sample_cluster, id.vars = c("sample_id", "cluster"), value.name = "median_expression", variable.name = "antigen")
expr_median_sample_cluster <- dcast(expr_median_sample_cluster_melt, cluster + antigen ~ sample_id, value.var = "median_expression")
rownames(expr_median_sample_cluster) <- paste0(expr_median_sample_cluster$cluster, "_", expr_median_sample_cluster$antigen)

clusters_keep <- names(which((rowSums(freq < 5) == 0)))

expr_median_sample_cluster <- expr_median_sample_cluster[expr_median_sample_cluster$cluster %in% clusters_keep, ]

expr_median_sample_cluster <- expr_median_sample_cluster[rowSums(expr_median_sample_cluster[, md$short_name]) > 0, ]


```



```{r diff_expr2_fit_model}
### Fit the LMM for each marker separately
fit_gaussian2 <- lapply(1:nrow(expr_median_sample_cluster), function(i){
  # i = 1
  data_tmp <- data.frame(y = as.numeric(expr_median_sample_cluster[i, md$short_name]), md)
  
  fit_tmp <- lmer(formula_lmer, data = data_tmp)
  
  ## Fit contrasts one by one
  out <- apply(K, 1, function(k){
    contr_tmp <- glht(fit_tmp, linfct = matrix(k, 1))
    summ_tmp <- summary(contr_tmp)
    pval <- summ_tmp$test$pvalues
    return(pval)
  })
  
  return(out)
  
})

pvals <- do.call(rbind, fit_gaussian2)
colnames(pvals) <- paste0("pval_", contrast_names)
rownames(pvals) <- paste0(expr_median_sample_cluster$cluster, "_", expr_median_sample_cluster$antigen)

## Adjust the p-values
adjp <- apply(pvals, 2, p.adjust, method = "BH")
colnames(adjp) <- paste0("adjp_", contrast_names)
head(adjp)

```


### Plot median expression of all the markers in each cluster


```{r diff_expr2_plot_median_expr}
ggdf <- expr_median_sample_cluster_melt

## Add info about samples
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition1 <- factor(md$condition1[mm])
ggdf$condition2 <- factor(md$condition2[mm])
ggdf$condition <- factor(md$condition[mm])

## Plot for condition A
ggplot(ggdf[ggdf$condition2 == "A", , drop = FALSE]) +
  geom_boxplot(aes(x = antigen, y = median_expression, color = condition, fill = condition), position = position_dodge(), alpha = 0.5, outlier.color = NA) +
  geom_point(aes(x = antigen, y = median_expression, color = condition), alpha = 0.8, position = position_jitterdodge()) +
  facet_wrap(~ cluster) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_color_manual(values = color_conditions) +
  scale_fill_manual(values = color_conditions)

```


### Plot heatmap with significant markers

```{r diff_expr2_plot_heatmap_with_significant_markers}
## Keep significant markers for condition A and sort them by significance
sign_clusters_markers <- names(which(sort(adjp[, "adjp_HvsS_A"]) < FDR_cutoff))

## Keep samples for condition A and normalize to mean = 0 and sd = 1
expr_median_sample_cluster_norm <- normalization_wrapper(expr_median_sample_cluster[sign_clusters_markers, md$short_name[md$condition2 == "A"]])

## Get the adjusted p-values
sign_adjp <- adjp[sign_clusters_markers , "adjp_HvsS_A"]

plot_differential_heatmap_wrapper(expr_norm = expr_median_sample_cluster_norm, sign_adjp = sign_adjp, condition = md[colnames(expr_median_sample_cluster_norm), "condition"], color_conditions = color_conditions)

```

















# Further analysis of specific subpopulations 

Describe that one could extract cell populations of interest and rerun this pipeline again.






# Session Info


```{r sessionInfo}
sessionInfo()
```










<!-- # Author contributions -->

<!-- # Competing interests -->

<!-- # Grant information -->

<!-- # Acknowledgments -->




# References

