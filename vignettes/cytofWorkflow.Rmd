---
title: "CyTOF workflow"
author: 
  - name: Malgorzata Nowicka
    affiliation: a,b
    email: gosia.nowicka@uzh.ch
  - name: Mark D. Robinson
    affiliation: a,b
address:
  - code: a
    address: Institute for Molecular Life Sciences, University of Zurich, Zurich, 8057, Switzerland
  - code: b
    address: SIB Swiss Institute of Bioinformatics, University of Zurich, Zurich, 8057, Switzerland
abstract: Abstract. 
documentclass: extarticle
fontsize: 10pt
papersize: a4
bibliography: bibliography.bib
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{CyTOF workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

<!-- To render this document: -->

<!-- cd cytofWorkflow/vignettes -->

<!-- rmarkdown::render('cytofWorkflow.Rmd') -->

<!-- knitr::purl('cytofWorkflow.Rmd') -->


```{r setup_knitr, include=FALSE, cache=FALSE}
library(knitr)
knitr::opts_chunk$set(cache = 2, warning = FALSE, message = FALSE, cache.path = "cache/", fig.path = "figure/")
```


# Introduction

Describe what CyTOF is and its applications.

Shortly explain what is presented in this workflow.

# Data preprocessing

From Carsten:

PBMC staining and acquisition by mass cytometry were performed as described previously (Hartmann et al. 2017). Data was normalized using the standalone MATLAB normalizer (Version 2013b; Finck et al. 2013), marker expression was controlled in FlowJo (Version10.1r5) by using a biologic positive and negative control and patient samples were de-barcoded using Boolean gating.

# Data importing and normalization

Currently, FCS, metadata and panel files are available in the `extdata` subdirectory of this package installation.

In the future, all of them will be available on FlowRepository so I will have to describe how to download them.

```{r data_dir}
library(cytofWorkflow)

data_dir <- system.file("extdata", package = "cytofWorkflow")

```


Load metadata and panel files:

```{r load_metadata}
md <- read.table(file.path(data_dir, "cytofWorkflow_metadata.xls"), header = TRUE, as.is = TRUE)

rownames(md) <- md$short_name

## Make sure condition variables are factors with the right levels
md$condition1 <- factor(md$condition1, levels = c("Healthy", "Sick"))
md$condition2 <- factor(md$condition2, levels = c("A", "B"))
md$condition <- interaction(md$condition2, md$condition1, sep = "_", lex.order = TRUE)
## Add colors
md$color <- factor(md$condition, labels = c("#B17BA6", "#882E72", "#7BAFDE", "#1965B0"))
md

color_samples <- as.character(md$color)
names(color_samples) <- md$short_name

colors <- unique(md[, c("condition", "color")])
color_conditions <- as.character(colors$color)
names(color_conditions) <- colors$condition
```

```{r load_panel}
panel <- read.table(file.path(data_dir, "cytofWorkflow_panel.xls"), header = TRUE, as.is = TRUE)
head(panel)
```


An alternative to the approach below would be to use the `cytof_exprsMerge` function from `cytofkit`.

Load the raw FCS files:

```{r load_fcs}
library(flowCore)

file_names <- file.path(data_dir, md$file_name)
fcs_raw <- read.flowSet(file_names)
```

Extract the expression data for markers with `panel$Use` equal to 1, and normalize it using the arcsinh transformation:

```{r arcsinh_normalization}
## Find which markers to use
fcs_colnames <- colnames(fcs_raw)
fcs_isotope <- as.numeric(gsub("[[:alpha:]]", "", fcs_colnames))
mm <- match(panel$Isotope, fcs_isotope)
panel$fcs_colnames <- fcs_colnames[mm]
keep <- panel$fcs_colnames[panel$Use == 1]

## Extract expression + arcsineh normalization
expr <- fsApply(fcs_raw, exprs)
expr <- asinh(expr[, keep] / 5)
colnames(expr) <- panel$Antigen[panel$Use == 1]
```

Normalize the expression data to 0-1. Useful when for plotting heatmaps.

```{r 01_normalization}
rng <- apply(expr, 2, quantile, p = c(0.01, 0.99))

expr01 <- t((t(expr) - rng[1, ]) / (rng[2, ] - rng[1, ]))

expr01[expr01 < 0] <- 0
expr01[expr01 > 1] <- 1

```

Generate a variable with sample IDs.

```{r sample_ids}
sample_ids <- rep(md$short_name, fsApply(fcs_raw, nrow))
```

Plot distributions of marker expression.

```{r plot_merker_expression_distribution}
library(ggplot2)
library(reshape2)

ggdf <- data.frame(sample_id = sample_ids, expr)
ggdf <- melt(ggdf, id.var = "sample_id", value.name = "expression", variable.name = "antigen")
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition <- md$condition[mm]

ggplot(ggdf, aes(x = expression, color = condition, group = sample_id)) +
  geom_density() +
  facet_wrap(~ antigen, nrow = 4, scales = "free") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.title = element_blank(), legend.position = "right") +
  guides(color = guide_legend(ncol = 1)) +
  scale_color_manual(values = color_conditions)

```


Plot number of cells per sample

```{r plot_number_of_cells}
cell_table <- table(sample_ids)

ggdf <- data.frame(sample_id = names(cell_table), cell_counts = as.numeric(cell_table))

ggplot(ggdf, aes(x = sample_id, y = cell_counts, fill = sample_id)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = cell_counts), hjust=0.5, vjust=-0.5, size = 3) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1), legend.position = "none") +
  scale_fill_manual(values = color_samples, drop = FALSE) +
  scale_x_discrete(drop = FALSE)
```


# Marker ranking based on the non-redundancy score

The non-redundancy score (NRS) [@Levine2015] based on the PCA analysis.
Explain in detail why we calculate it. Useful if we want to work with a subset of markers but here we run the analysis with all the markers. 


```{r nrs_function}
NRS <- function(x, ncomp = 3){
  pr <- prcomp(x, center = TRUE, scale. = FALSE) 
  score <- rowSums(outer(rep(1, ncol(x)), pr$sdev[1:ncomp]^2) * abs(pr$rotation[,1:ncomp]))
  return(score)
}
```

```{r nrs_calculate}
## Split expression per sample
expr_split <- split(data.frame(expr), sample_ids)

nrs_sample <- sapply(expr_split, NRS)

nrs <- rowMeans(nrs_sample, na.rm = TRUE)
```


```{r plot_nrs}
## Plot NRS scores for ordered markers
antigens_ordered <- names(sort(nrs, decreasing = TRUE))

nrs_sample <- data.frame(nrs_sample)
nrs_sample$antigen <- rownames(nrs_sample)

ggdf <- melt(nrs_sample, id.var = "antigen", value.name = "nrs", variable.name = "sample_id")
ggdf$antigen <- factor(ggdf$antigen, levels = antigens_ordered)
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition <- md$condition[mm]

ggplot(ggdf, aes(x = antigen, y = nrs)) +
geom_point(aes(color = condition), alpha = 0.8, position = position_jitter(width = 0.3, height = 0)) +
  geom_boxplot(outlier.size = NA, fill = NA) +
  stat_summary(fun.y = "mean", geom = "point", shape = 21, fill = "white") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_color_manual(values = color_conditions) 

```

# MDS plot

```{r mds_median_expression}
# Get the median marker expression per sample
expr_median_sample <- aggregate(expr, by = list(sample_id = sample_ids), FUN = median)
rownames(expr_median_sample) <- expr_median_sample[, 1]
expr_median_sample <- t(expr_median_sample[, -1])
```

```{r mds_plotMDS}
library(limma)
mds <- plotMDS(expr_median_sample, plot = FALSE)
```


```{r mds_plot}
ggdf <- data.frame(PCA1 = mds$x, PCA2 = mds$y, sample_id = colnames(expr_median_sample))
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition <- md$condition[mm]

ggplot(ggdf, aes(x = PCA1, y = PCA2, color = condition)) +
	geom_point(size = 2) +
	geom_text(aes(label = sample_id), vjust = -0.5) +
	xlim(-1.2, 1.2) +
	theme_bw() +
	scale_color_manual(values = color_conditions) 

```


# Cell population identification with FlowSOM

Explain that identifying meaningful clusters is one of the most challenging parts and all the downstream analysis depend on it.
We use a slight modification of the FlowSOM workflow presented in its vignette. We find it more flexible.

```{r flowsom_som}
library(FlowSOM)
library(ConsensusClusterPlus)

## Run SOM with 100 clusters
set.seed(1234)
som <- SOM(expr)
```


```{r flowsom_meta_clustering, message = FALSE}
## Meta clustering into 20 clusters with ConsensusClusterPlus
codes <- som$codes
plot_outdir <- "consensus_plots"
nmc <- 20

mc <- ConsensusClusterPlus(t(codes), maxK = nmc, reps = 100, pItem = 0.9, pFeature = 1, title = plot_outdir, plot = "png", clusterAlg = "hc", innerLinkage = "average", finalLinkage = "average", distance = "euclidean", seed = 1234)

## Get cluster ids for each cell
code_clustering <- mc[[nmc]]$consensusClass
cell_clustering <- code_clustering[som$mapping[,1]]
```

One of the plots produced by `ConsensusClusterPlus` represents a score for each possible number of clusters from 2 to `r nmc`. It can be used for the elbow criterion to define the optimal number of clusters.

![Delta area](consensus_plots/consensus022.png)

You can also plot the SOM codes.

```{r som_codes_size}
## Get code sizes; sometimes not all the codes have mapped cells so they will have size 0
code_sizes <- table(factor(som$mapping[, 1], levels = 1:nrow(codes))) 
code_sizes <- as.numeric(code_sizes)

```

```{r som_codes_dimension_reduction}
## t-SNE dimension reduction with cytofkit when setting pca = FALSE does not work!
## So we use the Rtsne package directly.

# library(cytofkit)
# 
# codes_dr <- cytof_dimReduction(codes, method = "tsne", tsneSeed = 1234)
# colnames(codes_dr) <- c("dim1", "dim2")

## Run t-SNE
library(Rtsne)

set.seed(1234)
tsne_out <- Rtsne(codes, pca = FALSE)

```


```{r color_clusters}
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3", "#4EB265", "#90C987", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999")

```


```{r plot_som_codes}
codes_dr <- data.frame(tSNE1 = tsne_out$Y[, 1], tSNE2 = tsne_out$Y[, 2])
codes_dr$cluster <- factor(code_clustering)
codes_dr$size <- code_sizes

ggplot(codes_dr,  aes(x = tSNE1, y = tSNE2, color = cluster, size = size)) +
  geom_point(alpha = 0.9) +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))

```

## Plotting heatmaps


```{r plot_heatmap}
library(RColorBrewer)
library(pheatmap)

plot_clustering_heatmap_wrapper <- function(expr, expr01, cell_clustering, color_clusters){
  
  # Get the median expression
  expr_median <- aggregate(expr, by = list(cell_clustering), FUN = median)
  expr01_median <- aggregate(expr01, by = list(cell_clustering), FUN = median)
  
  # Get cluster frequencies
  clustering_table <- as.numeric(table(cell_clustering))
  
  # This clustering is based on the markers that were used for the main clustering
  d <- dist(expr_median[, antigens_ordered], method = "euclidean")
  cluster_rows <- hclust(d, method = "average")
  
  expr_heat <- as.matrix(expr01_median[, antigens_ordered])
  rownames(expr_heat) <- expr01_median[, 1]
  
  labels_row <- paste0(rownames(expr_heat), " (", round(clustering_table / sum(clustering_table) * 100, 2), "%)")
  labels_col <- colnames(expr_heat)
  
  # Row annotation for the heatmap
  annotation_row <- data.frame(cluster = rownames(expr_heat))
  rownames(annotation_row) <- rownames(expr_heat)
  
  names(color_clusters) <- rownames(expr_heat)
  annotation_colors <- list(cluster = color_clusters)
  
  # Colors for the heatmap
  color <- colorRampPalette(rev(brewer.pal(n = 8, name = "RdYlBu")))(100)
  
  pheatmap(expr_heat, color = color, cluster_cols = FALSE, cluster_rows = cluster_rows, labels_col = labels_col, labels_row = labels_row, display_numbers = TRUE, number_color = "black", fontsize_number = 4, annotation_row = annotation_row, annotation_colors = annotation_colors)
  
}

plot_clustering_heatmap_wrapper(expr, expr01, cell_clustering, color_clusters)

```


# Dimension reduction with t-SNE

Using only a subset of cells.

```{r tsne_duplicates_subsampling}
## Find and skip duplicates
dups <- which(!duplicated(expr))

## Data subsampling
## Create indices by sample
inds <- split(1:length(sample_ids), sample_ids) 

## How many cells to downsample per-sample
tsne_ncells <- pmin(table(sample_ids), 2000)  

## Get subsampled indices
set.seed(1234)
tsne_inds <- lapply(names(inds), function(i){
  s <- sample(inds[[i]], tsne_ncells[i], replace = FALSE)
  intersect(s, dups)
})

tsne_inds <- unlist(tsne_inds)

tsne_expr <- expr[tsne_inds, ]
```

```{r tsne_run}
## Run t-SNE
library(Rtsne)

set.seed(1234)
tsne_out <- Rtsne(tsne_expr, check_duplicates = FALSE, pca = FALSE)

```


```{r tsne_plot_one}
## Plot t-SNE
dr <- data.frame(tSNE1 = tsne_out$Y[, 1], tSNE2 = tsne_out$Y[, 2])
dr$sample_id <- sample_ids[tsne_inds]
dr$cell_clustering <- factor(cell_clustering[tsne_inds], levels = 1:nmc)

## One plot 
ggp <- ggplot(dr,  aes(x = tSNE1, y = tSNE2, color = cell_clustering)) +
  geom_point() +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))
ggp
```

```{r tsne_plot_facet_sample}
## Facet per sample
ggp + 
facet_wrap(~ sample_id) 
```


# Cluster reduction/merging and annotation


## Rerunning ConsensusClusterPlus with identified number of clusters

Applying the elbow criterion to the detla area Figure 1, we could deduce that there are 6 main clusters present in this dataset.

```{r flowsom_meta_clustering2, message = FALSE}
## Get cluster ids for each cell
nmc2 <- 6
code_clustering2 <- mc[[nmc2]]$consensusClass
cell_clustering2 <- code_clustering2[som$mapping[, 1]]
```


```{r plot_som_codes2}
## Plot new clustering2
codes_dr$cluster2 <- factor(code_clustering2)

ggplot(codes_dr,  aes(x = tSNE1, y = tSNE2, color = cluster2, size = size)) +
  geom_point(alpha = 0.9) +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))

```


```{r plot_heatmap2}
plot_clustering_heatmap_wrapper(expr, expr01, cell_clustering2, color_clusters[1:nmc2])

```


## Manual cluster merging based on the heatmap

(Should I rather use the `cutree()` function to get an 'automated' method for identifying clusters?)

```{r cluster_merging}
cluster_merging <- data.frame(original_cluster = 1:20, new_cluster = c("clA", "clH", "clH", "clF", "clH", "clE", "clB", "clF", "clG", "clB", "clE", "clE", "clG", "clD", "clB", "clC", "clD", "clB", "clB", "clC"))
cluster_merging

## New clustering3
mm <- match(cell_clustering, cluster_merging$original_cluster)
cell_clustering3 <- cluster_merging$new_cluster[mm]

mm <- match(code_clustering, cluster_merging$original_cluster)
code_clustering3 <- cluster_merging$new_cluster[mm]
```


```{r plot_som_codes3}
## Plot new clustering3
codes_dr$cluster3 <- factor(code_clustering3)

ggplot(codes_dr,  aes(x = tSNE1, y = tSNE2, color = cluster3, size = size)) +
  geom_point(alpha = 0.9) +
  theme_bw() +
  scale_color_manual(values = color_clusters) +
  guides(color = guide_legend(override.aes = list(size = 4), ncol = 2))
```


```{r plot_heatmap3, fig.cap='Heatmap for clustering3.'}
plot_clustering_heatmap_wrapper(expr, expr01, cell_clustering3, color_clusters[1:nlevels(cell_clustering3)])

```


# Differential analysis of cell population frequencies

Explain in details why we use GLMM.

Calculate cell frequencies in each cluster and sample


```{r diff_freqs}
freq_table <- table(cell_clustering3, sample_ids)
prop_table <- t(t(freq_table) / colSums(freq_table)) * 100

freq <- as.data.frame.matrix(freq_table)
prop <- as.data.frame.matrix(prop_table)
```

Fit a GLMM binomial with interactions and test contrasts.

```{r diff_freqs_define_model}
library(lme4)
library(multcomp)

## Define the model formula
model.matrix( ~ condition1 + condition2 + condition1:condition2, data = md)

## Create contrasts
contrast_names <- c("HvsS_A", "HvsS_B", "H_AvsS_B")
k1 <- c(0, 1, 0, 0)
k2 <- c(0, 1, 0, 1)
k3 <- c(0, 1, 1, 1)
K <- matrix(c(k1, k2, k3), nrow = 3, byrow = TRUE)
rownames(K) <- contrast_names
K

formula_glmer_binomial <- y/total ~ condition1 + condition2 + condition1:condition2 + (1|patient_id)
```


This approach works also when the experiment is not paired, i.e., there are unique patient IDs for each sample.

```{r diff_freqs_fit_model}
ntot <- colSums(freq)

### Fit the GLMM for each cluster separately
fit_binomial <- lapply(1:nrow(freq), function(i){

  data_tmp <- data.frame(y = as.numeric(freq[i, md$short_name]), total = ntot, md)

  fit_tmp <- glmer(formula_glmer_binomial, weights = total, family = binomial, data = data_tmp)

  ## Fit contrasts one by one
  out <- apply(K, 1, function(k){
    contr_tmp <- glht(fit_tmp, linfct = matrix(k, 1))
    summ_tmp <- summary(contr_tmp)
    pval <- summ_tmp$test$pvalues
    return(pval)
  })

  return(out)
  
})

pvals <- do.call(rbind, fit_binomial)
colnames(pvals) <- paste0("pval_", contrast_names)
rownames(pvals) <- rownames(freq)

## Adjust the p-values
adjp <- apply(pvals, 2, p.adjust, method = "BH")
colnames(adjp) <- paste0("adjp_", contrast_names)
adjp
```

## Plot proportions for all the clusters

We plot the proportions for contrast `"HvsS_A"`.

```{r diff_freqs_plot_props}
ggdf <- melt(data.frame(cluster = rownames(prop), prop), id.vars = "cluster", value.name = "proportion", variable.name = "sample_id")

## Add info about samples
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition1 <- factor(md$condition1[mm])
ggdf$condition2 <- factor(md$condition2[mm])
ggdf$condition <- factor(md$condition[mm])

## Plot for condition A
ggplot(ggdf[ggdf$condition2 == "A", , drop = FALSE]) +
  geom_boxplot(aes(x = condition, y = proportion, color = condition, fill = condition), position = position_dodge(), alpha = 0.5, outlier.color = NA) +
  geom_point(aes(x = condition, y = proportion, color = condition), alpha = 0.8, position = position_jitterdodge()) +
  facet_wrap(~ cluster, scales = "free", nrow = 2) +
  theme_bw() +
  theme(axis.text.x = element_blank(), 
  	axis.ticks.x = element_blank()) +
  scale_color_manual(values = color_conditions) +
  scale_fill_manual(values = color_conditions)

```


## Plot heatmap with significant cell populations

We plot the proportions for contrast `"HvsS_A"`.

```{r normalization_wrapper}
normalization_wrapper <- function(expr, th = 2.5){
  
  expr_norm <- apply(expr, 1, function(x){ 
    
    sdx <- sd(x, na.rm = TRUE)
    if(sdx == 0)
      x <- (x - mean(x, na.rm = TRUE))
    else 
      x <- (x - mean(x, na.rm = TRUE)) / sdx
    
    x[x > th] <- th
    x[x < -th] <- -th
    
    return(x)
  })
  
  expr_norm <- t(expr_norm)
  
}

```



```{r diff_freqs_asin_sqrt_transformation}
## Apply the arcsine-square-root transformation
asin_table <- asin(sqrt((t(t(freq_table) / colSums(freq_table)))))
asin <- as.data.frame.matrix(asin_table)

## Keep significant clusters for condition A and sort them by significance
FDR_cutoff <- 0.05
sign_clusters <- names(which(sort(adjp[, "adjp_HvsS_A"]) < FDR_cutoff))

## Keep samples for condition A and normalize to mean = 0 and sd = 1
asin_norm <- normalization_wrapper(asin[sign_clusters, md$short_name[md$condition2 == "A"]])

## Get the adjusted p-values
sign_adjp <- adjp[sign_clusters , "adjp_HvsS_A"]
```



```{r diff_freqs_plot_heatmap_with_significant_clusters}

plot_differential_heatmap_wrapper <- function(expr_norm, sign_adjp, condition, color_conditions, th = 2.5){
  
  ## Plot a heatmap
  labels_row <- paste0(rownames(expr_norm), " (", sprintf( "%.02e", sign_adjp), ")")
  labels_col <- colnames(expr_norm)
  
  annotation_col <- data.frame(condition = factor(condition))
  rownames(annotation_col) <- colnames(expr_norm)
  annotation_colors <- list(condition = color_conditions)
  
  color <- colorRampPalette(c("#87CEFA", "#56B4E9", "#0072B2", "#000000", "#D55E00", "#E69F00", "#FFD700"), space = "Lab")(100)
  breaks = seq(from = -th, to = th, length.out = 101)
  legend_breaks = seq(from = -round(th), to = round(th), by = 1)
  gaps_col <- as.numeric(table(annotation_col$condition))
  
  pheatmap(expr_norm, color = color, breaks = breaks, legend_breaks = legend_breaks, cluster_cols = FALSE, cluster_rows = FALSE, labels_col = labels_col, labels_row = labels_row, gaps_col = gaps_col, annotation_col = annotation_col, annotation_colors = annotation_colors, annotation_legend = FALSE)
  
  
}

plot_differential_heatmap_wrapper(expr_norm = asin_norm, sign_adjp = sign_adjp, condition = md[colnames(asin_norm), "condition"], color_conditions = color_conditions)

```



# Differential analysis of marker expression

## Overall marker expression

Using the `glmer` function with `family = gaussian` as shortcut to `lmer` is deparacated. One should use `lmer` directly.
`lmer` does not allow that the random effect is a variable that has unique values for each sample. Thus, sample IDs could not be used as a random effect.

```{r diff_expr1_fit_model}
formula_lmer <- y ~ condition1 + condition2 + condition1:condition2 + (1|patient_id)

### Fit the LMM for each marker separately
fit_gaussian <- lapply(1:nrow(expr_median_sample), function(i){
	# i = 1
  data_tmp <- data.frame(y = as.numeric(expr_median_sample[i, md$short_name]), md)

  fit_tmp <- lmer(formula_lmer, data = data_tmp)

  ## Fit contrasts one by one
  out <- apply(K, 1, function(k){
    contr_tmp <- glht(fit_tmp, linfct = matrix(k, 1))
    summ_tmp <- summary(contr_tmp)
    pval <- summ_tmp$test$pvalues
    return(pval)
  })

  return(out)
  
})

pvals <- do.call(rbind, fit_gaussian)
colnames(pvals) <- paste0("pval_", contrast_names)
rownames(pvals) <- rownames(expr_median_sample)

## Adjust the p-values
adjp <- apply(pvals, 2, p.adjust, method = "BH")
colnames(adjp) <- paste0("adjp_", contrast_names)
adjp
```


### Plot mediam expression of all the markers

Sorted by significance

```{r diff_expr1_plot_median_expr}
ggdf <- melt(data.frame(antigen = rownames(expr_median_sample), expr_median_sample), id.vars = "antigen", value.name = "median_expression", variable.name = "sample_id")

## Sort antigen by significance
ggdf$antigen <- factor(ggdf$antigen, levels = names(sort(adjp[, "adjp_HvsS_A"])))

## Add info about samples
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition1 <- factor(md$condition1[mm])
ggdf$condition2 <- factor(md$condition2[mm])
ggdf$condition <- factor(md$condition[mm])

## Plot for condition A
ggplot(ggdf[ggdf$condition2 == "A", , drop = FALSE]) +
  geom_boxplot(aes(x = antigen, y = median_expression, color = condition, fill = condition), position = position_dodge(), alpha = 0.5, outlier.color = NA) +
  geom_point(aes(x = antigen, y = median_expression, color = condition), alpha = 0.8, position = position_jitterdodge()) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_color_manual(values = color_conditions) +
  scale_fill_manual(values = color_conditions)

```


### Plot heatmap with significant markers

```{r diff_expr1_plot_heatmap_with_significant_markers}
## Keep significant markers for condition A and sort them by significance
sign_markers <- names(which(sort(adjp[, "adjp_HvsS_A"]) < FDR_cutoff))

## Keep samples for condition A and normalize to mean = 0 and sd = 1
expr_median_sample_norm <- normalization_wrapper(expr_median_sample[sign_markers, md$short_name[md$condition2 == "A"]])

## Get the adjusted p-values
sign_adjp <- adjp[sign_markers , "adjp_HvsS_A"]

plot_differential_heatmap_wrapper(expr_norm = expr_median_sample_norm, sign_adjp = sign_adjp, condition = md[colnames(expr_median_sample_norm), "condition"], color_conditions = color_conditions)

```


## Marker expression stratified by cell population

There maight be samples that have no cells assigned to a cluster or the number of cells is very low. This can be a problem as it introduces NAs because the median expression can not be calculated for such a sample or the median expression is calculated based on few cells which leads to higher uncertainty of this estimate.

We remove clusters which have too low counts.  

```{r diff_expr2_median_expression}

expr_median_sample_cluster <- aggregate(expr, by = list(sample_id = sample_ids, cluster = cell_clustering3), FUN = median, drop = FALSE)
expr_median_sample_cluster_melt <- melt(expr_median_sample_cluster, id.vars = c("sample_id", "cluster"), value.name = "median_expression", variable.name = "antigen")
expr_median_sample_cluster <- dcast(expr_median_sample_cluster_melt, cluster + antigen ~ sample_id, value.var = "median_expression")
rownames(expr_median_sample_cluster) <- paste0(expr_median_sample_cluster$cluster, "_", expr_median_sample_cluster$antigen)

clusters_keep <- names(which((rowSums(freq < 5) == 0)))

expr_median_sample_cluster <- expr_median_sample_cluster[expr_median_sample_cluster$cluster %in% clusters_keep, ]

expr_median_sample_cluster <- expr_median_sample_cluster[rowSums(expr_median_sample_cluster[, md$short_name]) > 0, ]


```



```{r diff_expr2_fit_model}
### Fit the LMM for each marker separately
fit_gaussian2 <- lapply(1:nrow(expr_median_sample_cluster), function(i){
  # i = 1
  data_tmp <- data.frame(y = as.numeric(expr_median_sample_cluster[i, md$short_name]), md)
  
  fit_tmp <- lmer(formula_lmer, data = data_tmp)
  
  ## Fit contrasts one by one
  out <- apply(K, 1, function(k){
    contr_tmp <- glht(fit_tmp, linfct = matrix(k, 1))
    summ_tmp <- summary(contr_tmp)
    pval <- summ_tmp$test$pvalues
    return(pval)
  })
  
  return(out)
  
})

pvals <- do.call(rbind, fit_gaussian2)
colnames(pvals) <- paste0("pval_", contrast_names)
rownames(pvals) <- paste0(expr_median_sample_cluster$cluster, "_", expr_median_sample_cluster$antigen)

## Adjust the p-values
adjp <- apply(pvals, 2, p.adjust, method = "BH")
colnames(adjp) <- paste0("adjp_", contrast_names)
head(adjp)

```


### Plot mediam expression of all the markers in each cluster


```{r diff_expr2_plot_median_expr}
ggdf <- expr_median_sample_cluster_melt

## Add info about samples
mm <- match(ggdf$sample_id, md$short_name)
ggdf$condition1 <- factor(md$condition1[mm])
ggdf$condition2 <- factor(md$condition2[mm])
ggdf$condition <- factor(md$condition[mm])

## Plot for condition A
ggplot(ggdf[ggdf$condition2 == "A", , drop = FALSE]) +
  geom_boxplot(aes(x = antigen, y = median_expression, color = condition, fill = condition), position = position_dodge(), alpha = 0.5, outlier.color = NA) +
  geom_point(aes(x = antigen, y = median_expression, color = condition), alpha = 0.8, position = position_jitterdodge()) +
  facet_wrap(~ cluster) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_color_manual(values = color_conditions) +
  scale_fill_manual(values = color_conditions)

```


### Plot heatmap with significant markers

```{r diff_expr2_plot_heatmap_with_significant_markers}
## Keep significant markers for condition A and sort them by significance
sign_clusters_markers <- names(which(sort(adjp[, "adjp_HvsS_A"]) < FDR_cutoff))

## Keep samples for condition A and normalize to mean = 0 and sd = 1
expr_median_sample_cluster_norm <- normalization_wrapper(expr_median_sample_cluster[sign_clusters_markers, md$short_name[md$condition2 == "A"]])

## Get the adjusted p-values
sign_adjp <- adjp[sign_clusters_markers , "adjp_HvsS_A"]

plot_differential_heatmap_wrapper(expr_norm = expr_median_sample_cluster_norm, sign_adjp = sign_adjp, condition = md[colnames(expr_median_sample_cluster_norm), "condition"], color_conditions = color_conditions)

```

















# Further analysis of specific subpopulations 

Describe that one could extract cell populations of interest and rerun this pipeline again.






# Session Info


```{r sessionInfo}
sessionInfo()
```










<!-- # Author contributions -->

<!-- # Competing interests -->

<!-- # Grant information -->

<!-- # Acknowledgments -->




# References

